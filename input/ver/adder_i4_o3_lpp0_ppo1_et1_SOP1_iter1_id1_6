module adder_i4_o3_lpp0_ppo1_et1_SOP1_iter1_id1 (in0, in1, in2, in3, out0, out1, out2);
//input/output declarations
input in0, in1, in2, in3;
output out0, out1, out2;
//intact gates wires 
	//no intact gates detected!
wire w_g0;//annotated subgraph inputs
wire w_in3, w_in2, w_in1, w_in0;
//annotated subgraph outputs
wire w_g19, w_g21;
//json input wires
wire j_in0, j_in1, j_in2, j_in3;
//json model
wire p_o0_t0, p_o0_t1, p_o0_t2, p_o0_t3, p_o1_t0, p_o1_t1, p_o1_t2, p_o1_t3;
//subgraph inputs assigns
assign w_in3 = in3;
assign w_in2 = in2;
assign w_in1 = in1;
assign w_in0 = in0;
//mapping subgraph inputs to json inputs
assign j_in0 = w_in0;
assign j_in1 = w_in1;
assign j_in2 = w_in2;
assign j_in3 = w_in3;
//json model assigns (approximated/XPATed part)
assign p_o0_t0 = ~j_in1 & j_in2 & j_in3;
assign p_o0_t1 = j_in1 & j_in3;
assign p_o0_t2 = j_in1 & j_in2 & ~j_in3;
assign p_o0_t3 = j_in0 & j_in1 & j_in2;
assign w_g19 = p_o0_t0 | p_o0_t1 | p_o0_t2 | p_o0_t3;
assign p_o1_t0 = j_in1 & j_in2 & j_in3;
assign p_o1_t1 = ~j_in1 & ~j_in2 & j_in3;
assign p_o1_t2 = ~j_in1 & j_in2 & ~j_in3;
assign p_o1_t3 = j_in1 & ~j_in2 & ~j_in3;
assign w_g21 = p_o1_t0 | p_o1_t1 | p_o1_t2 | p_o1_t3;
// intact gates assigns
assign w_g0 = 1'b0;
// output assigns
assign out0 = w_g0;
assign out1 = w_g21;
assign out2 = w_g19;
endmodule