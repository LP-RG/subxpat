from __future__ import annotations
from abc import ABC, abstractmethod
from collections import Counter
from typing import Any, Callable, Generic, Set, TypeVar

import networkx as nx


class Pattern(ABC):
    @abstractmethod
    def match(self, graph: nx.digraph.DiGraph) -> Set[Match]:
        """
            Search and return all occurrences of the pattern in the given graph.
        """
        raise NotImplementedError()

    @abstractmethod
    def __eq__(self, other: object) -> bool: return type(self) == type(other)
    @abstractmethod
    def __str__(self) -> str: return ''
    @abstractmethod
    def __hash__(self) -> int: return 0

    @abstractmethod
    def analyze_rules(
            self,
            match: Match,
            get_value: Callable[[Any], int],
            should_analyze: Callable[[Any], bool],
            result_container: Counter[str],
    ) -> Counter[str]:
        """
        :param match: the match (generated by the pattern) to analyze.
        :param get_value: the function to generate the value of a node.
        :param should_analyze: the function used to include a node or not.
        :param output: a counter that will be updated with the results of the analysis
        """
        pass


P = TypeVar('P', bound=Pattern)


class Match(ABC, Generic[P]):
    def __init__(self, pattern: P):
        """
            :param pattern: The pattern that generated this matching.
        """

        self.pattern = pattern

    @abstractmethod
    def __hash__(self) -> int: return 0

    @abstractmethod
    def __eq__(self, other: object) -> bool:
        return (
            type(self) == type(other)
            and self.pattern == other.pattern
        )

    def analyze_rules(
        self,
        get_value: Callable[[Any], int],
        should_analyze: Callable[[Any], bool],
        result_container: Counter[str] = None,
    ):
        """
        Use the pattern that generated the match to analyze the pattern rules on this match.

        :param get_value:  the function to generate the value of a node.
        :param should_analyze:  the function used to include a node or not.
        :param output: a counter that will be updated with the results of the analysis
        """

        if result_container is None: result_container = Counter()
        return self.pattern.analyze_rules(self, get_value, should_analyze, result_container)

    @abstractmethod
    def is_match_ok(self, predicate: Callable[[Any], bool]) -> bool:
        """If all relevant nodes of the match pass the predicate."""
    
    @abstractmethod
    def ok_count(self, predicate:Callable[[Any], bool]) -> int:
        """The numbers of times the match applies to the pattern."""
